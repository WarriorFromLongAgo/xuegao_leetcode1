# 第一章 MySQL 架构和历史

## 1.1 Mysql逻辑架构

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026352282-367adcbb-01e8-449b-b1d8-d4e61a13e7be.png)

```
第一层客户端，连接处理，授权认证，安全等等
第二层核心功能，解析，分析，优化，缓存以及内置函数等等。以及所有跨存储引擎的功能，存储过程，触发器，视图等。
第三层存储引擎，负责mysql中数据的存储和提取。不同的存储引擎之间也不会通信，而只是单纯的响应上层服务器的请求。
```

### 1.1.1 连接管理和安全性

```
每个客户端连接都会在服务器拥有一线程。连接的查询只会在这个线程中执行。服务器会负责缓存线程，因此不需要为了每一个新建的连接创建和销毁线程。
客户端连接到服务器，会进行验证，是否具有什么权限.
```

### 1.1.2 优化与执行

```
mysql会解析查询，进行优化，包括重写查询，决定表的读取顺序，以及选择合适的索引。同时用户也可以使用特殊的关键字告诉优化器，影响他的决策过程。也可以使用explain请求优化器解释优化的各个因素。
优化器不关心你用的是什么存储引擎，但是存储引擎对于优化查询是有影响的。优化器会请求存储引擎提供容量或者某个具体操作的开销，以及表数据的统计信息。
对于select，在解析查询前会优先查询缓存，如果能在其中找到对应的查询，服务器就不会再执行查询解析优化等过程。
```

## 1.2 并发控制

### 1.2.1 读写锁

## 1.3 事务

### ACID

```
原子性：每一个事务都是一个不可分割的，一起失败，一起成功
一致性：数据总是从一个一致性的状态编程另一个一致性的状态
隔离性：事务和事务之间相互隔离，不可分割
持久性：事务执行完成后，会永久的保存到数据库
```

使用事务批量提交

```
start transaction;
commit;
```

### 1.3.1 隔离级别

```
读未提交 read uncommitted
即使事务没有提交，其他事务都是可见的，事务可以读取未提交的数据，这就是脏读。
读已提交 read committed
一个事务开始的时候，只能够读取到别人已经提交的数据。
可重复读 repeatable read
可重复读解决了脏读的问题，保证了在同一个事务中多次读取同样记录的结果是一致的。
幻读：当前事务在读取某个范围的数据时，另一个事务在里面插入了新的数据，这样当前事务在读取是可能会出现幻读。
innodb和xtradb存储引擎通过多版本并发控制（mvcc）解决了幻读的问题。
串行化 serializable
串行化会在读取的每一行加锁，所以可能导致大量的超时和锁争夺的过程。
```

### 1.3.2 死锁

```
死锁是多个事务在同一资源上相互争夺，并请求锁定对方的占用资源，从而导致恶性循环的情况。
为了解决这个问题，数据库设置了各种死锁检测和死锁超时的机制。
innodb目前的死锁处理方式是：将持有最少的行级锁的事务回滚。
```

### 1.3.3 事务日志

### 1.3.4 mysql中的事务

```
两种事务型的存储引擎，innodb和NDB cluster，还有第三方的xtradb，pbxt。
```

**自动提交**

```
mysql默认的事务提交方式是自动提交。
查看自动提交
show variables like 'autocommit'
set autocommit = 1
1 是启动，0 是禁用
```

**隔离级别**

```
set transaction isolation level
设置事务的隔离级别，新的事务隔离级别会在下一个事务开始的时候生效。
可以在配置文件中设置整个事务的隔离级别，也可以设置当前会话的隔离级别
set session transaction isolation level read committed
```

**在事务中混合使用存储引擎**

```
是不可靠的，是不被允许的。，会发出警告。某些非事务的表上，不能回滚
```

**隐式锁定和显示锁定**

innodb采用的是两阶段锁定协议

```
隐式锁定
锁只有在执行commit，或者rollback的时候才会回滚，并且所有的锁都在同一时刻被释放
innodb会根据隔离级别在需要的时候进行加锁
显示锁定
select ... lock in share mode
select ... for update
```

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026420380-1876a48b-293c-4b0e-9abd-49ace1f4ae60.png)

## 1.4 多版本并发控制

```
mysql大部分的事务引擎都实现了行级锁，但不是简单的行级锁
基于并发性能的提升，都实现了mvcc，多版本并发控制
```

### mvcc

```
mvcc可以认为是行级锁的一个变种，但是他避免了很多加锁的操作，所以提升了性能。
虽然实现的机制有所不同，但是都实现了非阻塞的读操作，写也只是锁必要的行
mvcc的实现，会通过保存数据的某个时间节点的快照实现的
不管需要执行多长的时间，每个事物看到的数据都是一致的。根据事务开始的时间的不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。
不同的存储引擎的mvcc实现是不同的，常见的是乐观并发控制和悲观并发控制。
```

### innodb的mvcc

```
通过在每行记录的后面保存两个隐藏的列，一列存放行的创建时间，一列存放行的过期时间（或删除时间）。
当然存储的并不是实际的时间值，而是系统版本号
每开始一个新的事务，系统版本号都会递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行对比。
```

### **可重复读下的mvcc**

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026352504-1db8eb54-6276-4a3c-b15b-7f7a7bada231.png)

```
保存着两个列记录两个额外的系统版本号，是大多数读操作都不用加锁，使得读操作很简单，性能很好，也只能读取到符合标准的行，
不足是：每行记录都需要额外的空间，需要做更多的行检查操作，以及额外的维护工作
mvcc只在读已提交和可重复读下工作。
因为读未提交总是读取最新的数据行，而不是符合事务版本的行，而串行化会对所有读取的行加锁
```

## 1.5 mysql存储引擎

```
MySQL 将每个数据保存为数据目录下的一个子目录。
MySQL会在数据库子目录下创建一个和表同名的.frm文件，保存表的定义
例如创建一个mytable的表，mysql会在mytable.frm的文件里存放表的定义。
MySQL使用文件系统的目录和文件来保存数据库和表的定义，大小写敏感和具体的平台密切相关。
show table status like 'user'
```

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026352509-1787b864-2dbf-4d2e-b660-6e8cab192cab.png)

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026440948-6068c6b1-d364-44f9-a4b8-ec9b3a463b4e.png)

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026361021-bd247fa9-074d-4e0b-87e3-00ed748106c9.png)![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026360107-72e3c718-e389-40b8-bc63-47c0caeaa3a2.png)!

### 1.5.1 innodb存储引擎

```
innodb的数据存储在表空间，表空间是innodb管理的一个黑盒子，由一系列的数据文件构成。
在MySQL4.1以后的版本，innodb可以将每个表的数据和索引存放在单独的文件中。
innodb采用mvcc支持高并发，并且支持四种隔离级别，以及间隙锁，间隙锁可以通过加锁的方式防止幻影行的产生，它不仅仅加锁到查询的行上，还会对中间的行进行加锁。
```

## 1.5.2 myisam存储引擎

```
myisam不支持事务和行级锁，崩溃后无法安全修复
对于只读的数据，或者表比较小，可以忍受修复操作，可以使用。
但是默认请使用innodb存储引擎
myisam会将表存储在两个文件上，数据文件和索引文件。分别以.myd和.myi为扩展名。
```

## 1.5.3 MySQL其他存储引擎

## 1.5.4 第三方存储引擎

## 1.5.5 选择合适的存储引擎

事务

```
如果需要事务支持，那么innodb是很好的选择，如果不需要事务，并且主要是insert和select。那么myisam是很好的选择
```

备份

```
在线热备份，innodb
```

崩溃恢复

```
innodb
```

大数据量

```
infobright
```

### 1.5.6 转换表的存储引擎

```
alter table mytable engine = innodb
```

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026352954-c4254950-b606-4a1f-bbab-cc5fdbe5ef77.png)

## 1.6 MySQL 时间线

## 1.7 MySQL的开发模式

## 1.8 总结

# 第二章 基准测试

## 2.1 为什么需要基准测试

## 2.2 基准测试的策略

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026352278-afdfb415-28be-4d70-b3f7-f1d0e3cc9bc9.png)

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026352280-1c876d9d-c6c7-44d8-b4cf-44bae75cca18.png)

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026475736-3e5febf6-ac44-4ef5-bf6d-d7b86bea6ec5.png)

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026485135-dd2f929c-9c48-4776-846b-4fc1c8ccbd62.png)

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026352276-61be1d97-70b4-4e5d-83ed-53612bbcbc83.png)

# 第三章 服务器性能剖析

## 3.1 性能优化简介

# 第四章 schema与数据类型优化

## 4.1 选择优化的数据类型

更小的通常更好

简单就好

尽量避免null

### 4.1.1 整数类型

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026354160-793e3c88-b572-4f60-aa04-e92ceaff3678.png)

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026352512-52be9ec7-0ce2-4e45-a59c-2b2cbbe278b8.png)

### 4.1.2 实数类型

```
实数是带有小数部分的数字，他们不只是为了存储小数部分，也可以使用decimal存储比bigint还大的整数。
```

### 4.1.3 字符串类型

```
varchar
char
```

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026352515-73f3b543-12a7-4118-9ed3-02a5fdc73fe5.png)

![image](https://cdn.nlark.com/yuque/0/2020/png/1519834/1601026504032-42805e37-d64c-466f-a5d8-45c0bbf476b2.png)

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026352515-74899400-1cc9-409f-9869-dd13a69dfe10.png)

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026352947-417f2624-8119-427b-9dad-3c34c0220edd.png)

```
尽量使用更短的的字符串长度来存储
```

### 4.1.4 时间类型

datetime

![image](https://cdn.nlark.com/yuque/0/2020/png/1519834/1601026352519-2217e40d-5e82-451e-9758-ecbfd87ee292.png)

timestamp

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026352278-b9ffd416-8161-4547-b7fe-dc3252c48744.png)

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026352279-94b25c7b-a3d9-4cb4-b65b-9448e96dd987.png)

![image](https://cdn.nlark.com/yuque/0/2020/png/1519834/1601026524764-27d8e0b0-bf8a-47ed-bdc6-7ff3d13a8841.png)

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026354779-ffca90b5-1176-4ab1-8d3f-1332ce49cefc.png)

## 4.2 schema设计中的陷阱

### 4.2.1 太多的列

### 4.2.2 太多的关联

### 4.2.3 全能的枚举

### 4.2.4 变相的枚举

## 4.3 范式和反范式

在范式的数据库中，每个事实的数据出现且只出现一次，

在反范式的数据库中，信息是冗余的，可能会存储在多个地方

### 4.3.1 范式的优缺点

```
范式的更新操作通常比反范式快
当数据较好的范式化时，就只有很少或者没有重复的数据，所以只需要修改更少的数据
范式化的表，数据量很少，操作起来很快
很少的数据意味着在很少的时候需要使用distinct和group by，在反范式化的表中必须使用distinct或者group by才可以获取唯一的部门列表
```

### 4.3.2 反范式的优缺点

```
反范式的表，所有的数据可能都在一张表里面
```

### 4.3.3 混用范式和反范式

## 4.4 缓存表和汇总表

### 4.4.1 物化视图

### 4.4.2 计数器

## 4.5 加快 alter table的速度

# 第五章 创建高性能的索引

### 如果使用的是orm，是否需要关心索引？

```
需要，
orm在查询的时候，很难生成适合索引的查询，无论是多么复杂的orm工具，在精妙和复杂的索引面前，都是辣鸡。
```

## 5.1 索引基础

### 5.1.1 索引类型

```
索引是存储引擎层实现的，而不是服务层
所以没有统一的索引标准，不同的存储引擎的索引，工作方式不一样。
```

### B+ tree

![image](https://cdn.nlark.com/yuque/0/2020/png/1519834/1601026357183-06ee398f-beed-4bd9-82fd-18b2a258368d.png)

```
B-tree可以加快访问数据的速度，因为存储引擎不需要再全表扫描来获取需要的数据，可以从索引的根节点开始搜索，
根节点的槽中存放了指向子节点的指针，
通过比较节点页的值，和要查找的值找到合适的指针进入下层子节点，这些节点定义了子节点页的上限和下限。
叶子节点比较特别，他们的指针指向的是被索引的数据，而不是其他的节点页，
B-tree是按照顺序存储的，所以很适合查找范围数据
```

**全值匹配**

```
和索引的所有列进行匹配
```

**匹配最左前缀**

```
前面提高的索引可用于查找所有姓为XX的人，即使只使用第一列
如果是一个组合索引，不能够直接使用组合索引的第二列，必须从组合索引的第一列开始使用
```

**匹配列前缀**

**匹配范围值**

**精准匹配某一列并范围匹配另外一列**

**只访问索引的查询**

```
如果查询只需要访问索引，那么无需访问数据行
```

**order by操作**

注意

```
1，如果不是按照索引的最左列开始查找，则无法使用索引
2，不能跳过索引的列
3，如果查询中有某个列的范围查询，则右边的所有列都无法使用索引优化
```

![image](https://cdn.nlark.com/yuque/0/2020/png/1519834/1601026352280-784b6f77-a740-43bc-9d12-97780b2e041c.png)

### hash索引

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026352274-21c1dc7b-a633-4c21-8e46-ab9bbdf074fb.png)

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026557670-00b2c0f7-782e-45d9-b635-b88958f59045.png)

![image](https://cdn.nlark.com/yuque/0/2020/png/1519834/1601026352279-c99756a0-d300-4183-8dc6-c06635045169.png)

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026362149-7124f724-127b-4ba4-9280-f1d95da91f9c.png)

```
MySQL 先计算Peter的哈希值，并使用该值寻找对应的记录指针，因为f(Peter)=8784，所以mysql在索引中查找8784，可以找到指向第三行的指针，最后比较第三行的值是否为Peter，以确保是找到的行
```

优点

```
因为索引本身只需要存储对应的哈希值，所以索引的结构十分紧凑，查找非常快
```

缺点

```
1，哈希索引只包含哈希值和行指针，而不存储字段值，
    所以不能使用索引中的值来避免读取行，不过访问内存中的行的速度非常快
2，哈希索引数据并不是按照索引值的顺序存储的，所以也无法用于排序
3，哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的
    例如在数据列（A，B）上建立哈希索引，如果查询只有数据列A，是无法使用索引的
4，哈希索引只支持等值比较查询，包括=，in，<==>，（注意<>和<==>是不一样的操作），也不支持任何范围查询，比如 >
5，访问哈希索引的数据非常快，除非有很多哈希冲突。当出现哈希冲突的时候，存储引擎必须遍历链表中的所有行指针，逐行进行比较，直到找到所有符合条件的行
6，如果哈希冲突很多的话，一些索引的维护操作代价也会非常高，
    例如在某个选择性很低，哈希冲突非常多的列上，建立哈希索引。那么当表中删除一行的时候，存储引擎需要遍历哈希值的链表中的每一行，找到并删除对应行的引用，冲突越多代价越大。
```

哈希索引的适用范围

```
一旦适合使用哈希索引，性能的提升非常明显
innodb有特殊的功能，自适应哈希索引。当innodb注意到某些索引值被使用得非常频繁的时候，他会在内存中基于B+tree索引之上建立一个哈希索引，这样就可以让B+tree索引也有哈希索引的一些特点
这是一个完全自动的行为，用户无法控制或者配置，不过如果有必要的话，完全可以关闭该功能
```

### 空间数据索引

GIS支持

开源关系型数据库中对GIS解决方法做的比较好的是，postgresql的postgis

### 全文索引

```
他查找的是文本中的关键词，而不是直接比较索引中的值。
全文索引更类似于搜索引擎所做的事情。使用match，against，而不是简单的where操作
```

### 其他索引

```
聚簇索引
覆盖索引
```

## 5.2 索引的优点

```
1，索引减少了服务所需要扫描的数据数量
2，索引可以帮助服务避免临时表和排序
3，索引可以将随机IO变为顺序IO
```

注意

```
索引并不总是最好的工具
对于小型的表，全表扫描效率更高
对于大中型的表，建立索引带来的额外工作，大于索引带来的性能提升
对于特大的表，应该使用其他技术
如果表的数量特别多，可以建立一个元数据信息表，用来查询需要用到的某些特性
例如执行那些需要聚合多个应用分布在多个表的数据查询，则需要记录哪个用户的信息存储在哪个表的元数据，这样在查询的时候就可以直接忽略那些不包含指定用户数据的表
对于大型系统，这是一个常用的技巧。infobright就是这样的技巧
对于TB级别的数据，单条定位的意义不大，所以经常会使用块级别的元数据技术来代替索引
```

## 5.3 高性能的索引策略

### 5.3.1 独立的列

```
如果查询的列不是独立的，那么mysql就不会使用索引
下面的查询无法使用actor_id索引
select actor_id from actor where actor_id + 1 = 10
下面这个也是一个常见的使用索引的错误
select ... where TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10
```

### 5.3.2 前缀索引和索引选择性

### 前缀索引简介

### 如何创建前缀索引

```
alter table sakila.city_demo add key (city(7));
```

### 前缀索引的特点

```
前缀索引是一种能使索引更小，更有效的办法，但另一方面也有缺点
MySQL无法使用前缀索引做order by和group by，也无法使用前缀索引做覆盖扫描
```

### 5.3.3 多列索引

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026352509-be63049b-c183-4619-8e84-f486b2ea513e.png)

![image](https://cdn.nlark.com/yuque/0/2020/png/1519834/1601026352518-dab2c84c-237b-4ac2-a581-d079a779c666.png)

### 两个单列索引的联合

```
查询能够同时使用单个单列进行扫描，并将结果合并
1，OR
2，AND
3，1和2的联合使用
```

### 索引合并策略

索引合并策略有时候是一种优化，但是也说明索引建立得很糟糕

```
1，当出现服务器对多个索引出现相交的操作的时候，通常有多个and操作，通常意味着需要一个包含所有相关列的索引，而不是多个单列索引
2，对多个索引做联合操作时，通常需要消耗大量的CPU和内存资源
3，优化器不会把这些计算到查询成本，优化器只关心随机页面读取。导致该执行计划还不如直接走全表扫描，
    还不如使用union性能会更好
explain 中看到有索引合并，应该好好检查查询和表的结构
也可以通过 optimizer_switch 来关闭索引合并的功能
也可以使用 ignore index 提示让优化器忽略掉某些索引
```

### 5.3.4 合适的索引列顺序

### 5.3.5 innodb的聚簇索引

![image](https://cdn.nlark.com/yuque/0/2020/png/1519834/1601026361924-cd1a15e6-ff7f-4c6b-a37e-890246cb65d6.png)

```
一个表只有一个聚簇索引。主键列一般就是聚簇索引
如果没有定义主键，innodb会选择一个唯一的非空索引代替，如果没有这样的索引，innodb会选择隐式定义一个主键来
作为聚簇索引
隐式的聚簇索引是int(6)的
```

### 聚簇索引的聚集数据的优点

```
1，将聚集的相关数据保存在一起，例如实现电子邮箱时，可以根据用户ID来聚集数据
2，访问数据更快，聚簇索引将数据和索引保存在同一个B+tree里面，因此从聚簇索引中获取数据通常比从非聚簇索引
中获取数据更快
3，使用覆盖索引扫描的查询，可以直接使用叶节点中的主键值
```

### 聚簇索引的聚集数据的缺点

```
1，聚簇索引极大的减少了磁盘IO，但是如果数据放在内存中，便没有必要了
2，插入的时候会很慢，
3，更新聚簇索引的代价很高，因为会强制innodb将每个被更新的行移动到新的位置
4，
5，聚簇索引可能会导致全表扫描变慢，尤其是行比较稀疏的时候，或者由于页分裂导致数据存储不连续的时候
6，二级存储可能比较大，因为二级索引的叶子节点包含了引用行的主键列
7，二级索引访问需要两次查找，而不是一次
    因为二级索引中保存的是行指针，二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值
    存储引擎需要找到二级索引里面的叶子节点获取对应的主键值，然后根据这个值去聚簇索引中寻找对应的行
```

![image](https://cdn.nlark.com/yuque/0/2020/png/1519834/1601026585606-9642341a-7488-4dd5-9afa-1c726a6fcf63.png)

```
聚簇索引的每一个叶子节点都包含了主键值，事务ID，用于事务和MVCC的回滚指针，以及所有的剩余列。
```

![image](https://cdn.nlark.com/yuque/0/2020/png/1519834/1601026593076-d4df05df-dbd2-4a02-8826-c48f9020c0d3.png)

### 在innodb中按主键顺序插入行

```
因为主键的值是顺序的，所以innodb把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子的时候，innodb的默认最大填充因子是页大小的15/16，下一条记录就会写入新的页中。
数据按照这个顺序加载，主键页就会近似于被顺序的记录写满。但是二级索引页可能是不一样的。
在插入的时候，新行的主键值不一定比之前插入的大，所以innodb总是无法直接把新行插入到索引的最后。
总是要为新行寻找合适的位置，通常是已有数据的中间位置，并且分配空间，这会增加很多的额外工作，导致数据分布不够优化。
当这些随机值插入到聚簇索引后，也许需要做一次 optimize table，来重建表并优化页的填充
```

![image](https://cdn.nlark.com/yuque/0/2020/png/1519834/1601026600668-164b2643-0b26-4cf5-a347-5693d6f62335.png)

### 5.3.6 覆盖索引

```
索引的确是一种查找数据的高效方式，但是mysql也可以直接使用索引来直接获取列的数据，这样就不再需要读取数据行。
如果索引的叶子节点已经要包含要查询的数据，那么就没必要再进行回表查询。
定义：如果一个索引包含所有需要查询的字段的值，我们就称为覆盖索引
```

### 5.3.7 使用索引扫描来排序

### 5.3.8 压缩（前缀压缩）索引

### 5.3.9 重复索引和冗余索引

![image](https://cdn.nlark.com/yuque/0/2020/png/1519834/1601026978634-42c3aa9e-eddb-45dd-8ca2-0282bd8e5e3b.png)

![image](https://cdn.nlark.com/yuque/0/2020/png/1519834/1601026986708-3e86a476-93e8-43e3-bf7f-f447c44f1457.png)

## 索引越多插入越慢

![image](%E9%AB%98%E6%80%A7%E8%83%BDMysql/1601026991468-abe57bb7-07a6-4992-87bf-94f43579ff34.png)

### 5.3.10 未使用的索引

```
建议删除
```

### 5.3.11 索引和锁

```
索引可以让查询锁定更少的行，
```

## 5.4 索引案例学习

### 5.4.1 支持多种过滤条件

### 5.4.2 避免多个范围查询

### 5.4.3 优化排序

## 5.5 维护索引和表

```
维护表的目的
找到并修复损坏的表，维护准确的索引统计信息，减少碎片
```

### 5.5.1 找到并修复损坏的表







### 5.5.2 更新索引统计信息

### 5.5.3 减少索引和数据的碎片



## 5.6 总结

# 第六章 查询性能优化

## 6.1 为什么查询速度会慢？

## 6.2 慢查询优化

```
1，确认应用程序是否在检索大量超过需要的数据，这通常意味着访问了太多的行，但也有可能是访问了过多的列
2，确认MySQL服务器层是否在分析大量超过需要的数据行
```

### 6.2.1 是否向数据库请求了不需要的数据？

```
有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序抛弃，这会给MySQL服务器带来额外的负担，并增加网络开销，也会消耗CPU和内存。
```

### 查询不需要的记录

```
我们以为MySQL只会返回需要的数据，实际上MySQL是先返回全部结果集再计算。
实际上MySQL会查询出全部的结果集，客户端会接收全部的结果集，然后抛弃其中大部分数据
```

### 多表联查时返回全部列



### 总是取出全部列

```
select *
```

### 查询重复相同的数据

```
这里会涉及到缓存
```

### 6.2.2 MySQL是否在扫描额外的记录

对于MySQL最简单的衡量查询开销的三个指标如下

```
响应时间
扫描的行数
返回的行数
```



### 响应时间

```
响应时间和排队时间
服务时间是指数据库处理这个查询真正花了多少时间。
排队时间是指服务器因为等待某些资源而没有真正执行查询的时间——可能是等IO操作完成，也可能是等行锁
```

### 扫描的行数和返回的行数

```
分析时，查看该查询扫描的行数是非常有帮助的，这在一定程度上，说明该查询的效率高不高
```

### 扫描的行数和访问的类型

```
MySQL有好几种方式可以返回一行的数据，有些需要扫描一行，有些需要扫描多行，有些方式无需扫描就可以返回
```









**MySQL三种方式使用where条件，从好到坏依次是**

```
1，在索引中使用where条件过滤不匹配的记录，这是在存储引擎层实现的
2，使用覆盖索引扫描，直接从索引中过滤不需要的记录并返回命中的结果，这是在MySQL服务器层完成的，但无需回表查询记录
3，从数据表中返回数据，然后过滤不满足的数据，MySQL需要先从数据表中读出记录然后过滤
注意
select actor_id, count(*) from film_actor group by actor_id
这个查询需要读取几千行数据，但是只返回200行，没有什么索引能够让这样的查询减少需要扫描的行数
MMySQL不会告诉你我们生成结果实际上需要扫描多少行数据，只会告诉你生成结果时返回了多少行数据，
扫描的行数大部分被where语句过滤了，对最终的结果并没有贡献
我们删除MySQL的索引后，会直接扫描所有的行，然后根据where语句进行筛选，最终只返回10行
如果发现查询需要扫描大量的数据，但是只返回少数行，可以尝试以下的方法
1，使用覆盖索引扫描，对所有的查询字段建立索引，就不需要回表了
2，XXX
3，重写这个复杂的查询，使他变得简单一点，能够被MySQL高效的查询
```

## 6.3 重构查询的方式

### 6.3.1 一个复杂的查询还是多个简单的查询

```
我们在很多时候都认为，应该一条sql完成更多的事情，认为网络通信，查询解析和优化是非常耗时间的过程
实际上在MySQL中这一条并不适用，
MySQL在设计上，连接和断开连接都非常的轻量，在返回一个简单的查询结果很高效，现在的网络和CPU都是非常快的，
每秒查询数十W次的简单查询都是没问题的，所以现在运行多个小查询已经不是问题了。
MySQL内部从内存中获取数据是很快的，但是返回数据给客户端是很慢的
在其他条件都相同的情况下，做尽可能少的查询是很有必要的。
```

### 6.3.2 切分查询

删除

```
可以将大的范围删除，变成多个小的范围删除，甚至变成一条条的删除，甚至加上延迟
```

### 6.3.3 分解关联查询

![image-20200325141647983](E:\GithubClone\My_MarkDown\数据库 SQL\pictrue\image-20200325141647983.png)

```
让缓存的效率更高，
分解后可以减少锁的竞争
在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展
查询本身的效率也会有所提升
可以减少冗余记录的查询
```

## 6.4 查询执行的基础

![image-20200325153335331](E:\GithubClone\My_MarkDown\数据库 SQL\pictrue\image-20200325153335331.png)

```
客户端首先发送一条查询到服务端
服务端先检查缓存，如果缓存里面有就直接返回
如果没有，那么就对SQL进行解析，预处理，优化，再由优化器生成对应的执行计划
MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询
将结果返回给客户端
```

### 6.4.1 MySQL客户端/服务端通信协议

```
MySQL客户端和服务端的通信都是半双工的，那么意味着在同一时刻，要么是服务端向客户端发送，要么是客户端向服务器发送
这种协议让MySQL非常的简单快速
但是也让MySQL有很多的限制，一旦一端开始发送消息了，一端必须要全部接收所有的消息，才能进行响应
```

### 查询状态

**sleep**

```
线程正在等待客户端发送新的请求
```

query

```
线程正在执行查询，或者正在将结果发送给客户端
```

locked

```
MySQL服务器层：
    线程正在等待表锁，
    在存储引擎层实现的锁，例如innodb的行锁，并不会有这个状态
    对于myisam这是一个典型的状态，但是其他没有行锁的引擎中也经常会出现
```

analyzing and statistics

```
线程正在收集存储引擎的统计信息，并生成查询的执行计划
```

copying to tmp table [on disk]

```
线程正在执行查询，并且将其结果集都放到一张临时的表里面
    这种状态要么是group by，或者是order by状态，或者是union操作
如果这个状态后面还有 on disk标志，那表示MySQL正在将一个内存临时表存放到硬盘
```

sorting result

```
线程正在对结果集进排序操作
```

sending data

```
1，线程可能在多个状态之间传递数据
2，在生成结果集
3，在向客户端发送数据
```

### 6.4.2 查询缓存

### 6.4.3 查询优化处理

```
查询的下一个生命周期是，解析SQL，预处理，执行优化，转换成SQL执行计划
```

### 语法解析器和预处理

```
语法解析器
MySQL通过关键字将SQL语句进行解析，并生成一颗对应的解析树
MySQL将使用MySQL语法规则验证和解析查询
例如：
    他将验证是否使用错误的关键字
    或者使用关键字的顺序是否正确
    验证引号前后是否可以正确匹配
预处理器
根据MySQL的一些规则，检查解析树是否合法
检查数据表和数据列是否存在
解析名字和别名，看看是否有歧义
```

### 查询优化器

```
一条查询可以有多种查询方式，最后都返回相同的结果
有优化器的作用是找到这其中最好的执行计划
MySQL将使用基于成本的优化器，他将尝试预测一个查询使用某种执行计划时候的成本，并选择其中成本最小的那个
```

![image-20200325193736494](E:\GithubClone\My_MarkDown\数据库 SQL\pictrue\image-20200325193736494.png)

### 优化器执行错误的执行计划

```
1，统计信息不准确，MySQL依赖存储引擎提供的统计信息来评估成本，但是有的时候很准确，有的时候差距很大
    比如innodb的mvcc架构，并不能维护一个数据表的行数和精确统计信息
2，执行计划的估算，不等同于实际执行的成本，所以即使统计信息精准，优化器给的执行计划仍然可能不是最优的
```

![image-20200325194742693](E:\GithubClone\My_MarkDown\数据库 SQL\pictrue\image-20200325194742693.png)

```
3，MySQL的最优可能和你想象的不一样，你可能希望执行时间尽可能的短，但是MySQL只是基于成本模型选择最优的
    执行计划，而有的时候这并不是最快的执行方式。所以根据执行成本来选择执行计划并不是完美的模型
4，MySQL从不考虑其他并发执行的查询，这可能会影响到当前查询的速度
5，MySQL也不一定总是基于成本的优化，有时也会基于一些固定规则，
    例如存在全文搜索match()子句，则存在全文索引的就使用全文索引。
    即使有的时候别的索引和where条件，可以远远比这种方式要快，MySQL也会使用对应的全文索引
6，MySQL不会考虑不受其控制的成本，例如执行存储过程或者用户自定义函数
7，优化器有的时候无法估算所有可能的执行计划，所以他可能错过了实际上最优的执行计划
```

### 优化器的静态优化

```
静态优化可以直接对解析树进行分析，并完成优化
```

![image-20200325195941855](E:\GithubClone\My_MarkDown\数据库 SQL\pictrue\image-20200325195941855.png)

### 优化器的动态优化

![image-20200325200001856](E:\GithubClone\My_MarkDown\数据库 SQL\pictrue\image-20200325200001856.png)

## 6.5 MySQL查询优化器的局限性

### 6.5.1 关联子查询

![image-20200325200455923](E:\GithubClone\My_MarkDown\数据库 SQL\pictrue\image-20200325200455923.png)

![image-20200325200506448](E:\GithubClone\My_MarkDown\数据库 SQL\pictrue\image-20200325200506448.png)

![image-20200325200519401](E:\GithubClone\My_MarkDown\数据库 SQL\pictrue\image-20200325200519401.png)

![image-20200325200528767](E:\GithubClone\My_MarkDown\数据库 SQL\pictrue\image-20200325200528767.png)

### 6.5.2 union的限制

![image-20200325200910229](E:\GithubClone\My_MarkDown\数据库 SQL\pictrue\image-20200325200910229.png)

![image-20200325200924599](E:\GithubClone\My_MarkDown\数据库 SQL\pictrue\image-20200325200924599.png)

### 6.5.3 索引合并并优化

```
当where子句中包含多个复杂条件的时候，MySQL能够访问单个表的多个索引以合并和交叉过滤的方式来定位
需要查找的行
```

### 6.5.4 等值传递

![image-20200325201209178](E:\GithubClone\My_MarkDown\数据库 SQL\pictrue\image-20200325201209178.png)

### 6.5.5 并行执行

```
MySQL无法利用多核的性能来并行查找
```

### 6.5.6 哈希关联

![image-20200325201324913](E:\GithubClone\My_MarkDown\数据库 SQL\pictrue\image-20200325201324913.png)

### 6.5.7 松散索引关联

### 6.5.8 最大值和最小值优化

### 6.5.9 在同一张表上查询和更新

## 6.6 查询优化器的提示

# 第七章 MySQL高级特性

# END